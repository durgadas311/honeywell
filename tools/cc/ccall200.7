.TH CCALL200 7 2/22/19 "cc-H200" "Honeywell 200/2000 C Compiler"
.ta 1i 2i 3i 4i 5i 6i 7i 8i
.SH NAME
ccall \- C Compiler Calling Convention
.SH DESCRIPTION
.B Cc
uses the facilities available in the H200/2000 Series architecture
to implement the following calling conventions.

The C compiler assumes address mode 4. A function may change the
address mode, however it must restore it to mode 4 before returning to
C code.

The memory layout of a program consists of \fB.text\fR, \fB.data\fR, \fB.bss\fR,
stack, and heap sections, in addition to the OS communication area at
location 0. The stack is placed at the end of the \fB.bss\fR section,
where additional space is added by the OS loader and possibly during
the link phase (using the \fB-t\fR option). The heap is oriented \fIabove\fR
the stack, and contains as much space as the OS loader provided via
the Upper Memory Limit field in the OS communication area. The stack (top of \fB.bss\fR)
is passed in X1. This is also the start of the heap.
Memory allocation library functions use this heap.

For numeric variables, the address used is of the rightmost character.
For initialized variables, a WM will be on the leftmost character.
Strings contain no punctuation except for a RM on the terminal
character, which is equivalent to the standard C '\0' character.
In other words, strings will have N+1 characters, however that terminal
character will not be '\0' and will have a RM on it. Array variable addresses
point to the first element, however that will be the rightmost character of
the first element. In the case of \fIchar\fR arrays, that is the same
as the leftmost character of the array (element size is one).

.SH FUNCTIONS

All external C names will have an underscore prepended when
exposed to the lower layers. This requires that any assembly code to receive
calls from C must have the underscore.

.SH "REGISTER USAGE"

The index register X1 is used as the stack pointer.

The index register X2 is used as the frame pointer ("bp"). However,
a function is not required to use X2 that way - but it must preserve
the caller's value.

Index registers X3 and X4 are reserved for use by the runtime.
Special implementations of operations, for example @div for integer divide,
expect to be able to use X3 and X4 without interference.

Index registers X5, X6, and X7 may be used in generated "C" code. X5 is considered
the "return value" (of functions as well as expressions).

.SH "STACK USE"

On entry to a function,
the 4-character space at \fB0(x1)\fR is available to store the return address.
The first passed parameter is at \fB4(x1)\fR.
The second passed parameter is at \fB8(x1)\fR, and so forth.
These represent the \fIrightmost\fR character of the stack entry.
With the exception of the return address, all stack entries should have a WM
at their leftmost character. \fIChar\fR values need to be placed on the
stack as \fIint\fRs.

In C code, the "frame pointer", X2, will point to the location
that X1 referenced on entry to the function. In those cases, it is
also used to restore the stack before return. Any function that uses
X2, as a frame pointer or anything else, must restore the caller's
value before returning.

The preamble for functions that is generated by C will be:
.PP
.in +4n
.EX
_func:
	scr	0(x1),070	// save ret adr
	lca	x2,-4(x1)	// save callers bp
	lca	x1,x2	// set new bp
	bs	@func,x1	// local var space
.EE
.in
.PP
The value for "@func" will be setup as the size of the local stack,
including the return address and saved frame pointer.

Within the body of the function, \fB4(x2)\fR refers to the first
passed parameter, \fB8(x2)\fR is the second, and so forth.
\fB-8(x2)\fR refers to the first local variable,
\fB-12(x2)\fR is the second, and so forth.

When making a function call, each parameter is placed on the
stack in reverse order. The last parameter is put in \fB0(x1)\fR,
the next previous is in \fB-4(x1)\fR, and so forth. Then the
stack is decremented by the size of the parameter list and the function
is called. As an example, this is a call to a function that passes
three parameters:

.PP
.in +4n
.EX
	lca	parm3,0(x1)
	lca	parm2,-4(x1)
	lca	parm1,-8(x1)
	bs	@12,x1
	b	_func
	ba	@12,x1
.EE
.in
.PP
In the above example, "@12" represents some variable that contains
the value required to adjust the stack (in the case, 12).
The H200/2000 architecture does not allow for immediate operands,
so all constants must be stored in memory somewhere.

The postamble for a function, excluding setting return value, will be:
.PP
.in +4n
.EX
	lca	x2,x1	// restore stack
	lca	-4(x1),x2	// restore callers bp
	lcr	0(x1),077	// return
.EE
.in
.PP

.SH "RUNTIME FUNCTIONS"

The C runtime functions used to implement operations,
such as integer division and bit-shifting, use the
H200/2000 Change Sequence Mode feature. These routines
accept a maximum of two address parameters and zero
or more variant characters. These routines do not use the
stack by default. A call to a CSM routine is performed
as follows:

.PP
.in +4n
.EX
	lcr	@rtn,064		// set CSR
	csm	parm1,parm2	// make call
.EE
.in
.PP
Note that the variable "@rtn" is a location in
memory that contains the address of the function.
This indirection is required due to the lack of immediate operands.

On entry to the routine, AAR and (optionally) BAR will
contain the parameter \fIaddresses\fR. So, indirection is
not required in the same way as would be the case for other instructions.
However, the routine must take into account that it has addresses,
not values. Care must be taken to avoid altering the caller's
variable unintentionally. The result of the routine is normally
placed in X5, unless the semantics call for altering the caller's
variables.

Because of the nature of the CSM instruction, a typical template
for a routine would be:

.PP
.in +4n
.EX
9:	csm
?rtn:	scr	x3,067	// get AAR
	scr	x4,070	// get BAR
	// perform function
	b	9b	// return to caller
	.data
@rtn:	.word	?rtn
.EE
.in
.PP
The routine actually loops back to the start where it executes CSM,
which returns to the caller. This arrangement leaves the CSR containing
?rtn so that the caller can make repeated calls without setting up CSR
again (although generated C code does not rely  on that).

.SH VARIABLES

Because of the problem with immediate operands, all non-local C variables
will have two symbols, one that points to the data and one that
contains the address of the data. This allows for simpler code generation.
For example, a declaration of "static int i;" will produce:
.PP
.in +4n
.EX
_i:	.word	^i	// address of variable
^i:	.word	0	// the actual variable
.EE
.in
.PP
When the compiler needs to use the address of the variable, it will
reference "_i". When it needs to (or can) directly access the value, it
will use "^i". This must be kept in mind if assembly code is going
to directly access global variables.

This also allows for use of indirection sometimes. For example,
a pointer variable p may be dereferenced like this:
.PP
.in +4n
.EX
	ba	(^p-3),x5
.EE
.in
.PP
Which is more efficient than the alternative:
.PP
.in +4n
.EX
	lca	^p,x6
	ba	0(x6),x5
.EE
.in
.PP

When accessing local variables, the compiler will convert the reference
into an expression that adds a constant to the frame pointer, and so
does not need a special location for the "address of".

.SH "SEE ALSO"
.SH DIAGNOSTICS
.SH BUGS
